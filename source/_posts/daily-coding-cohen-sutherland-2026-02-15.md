---
title: Cohen-Sutherland线段裁剪算法实现 - 图形学每日挑战
date: 2026-02-15 10:45:00
categories: [图形学, C++编程, 每日挑战]
tags: [图形学, 算法, Cohen-Sutherland, C++, 线段裁剪, 二维裁剪]
cover: https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/cohen-sutherland-2026-02-15/output.png
---

## 每日编程挑战：Cohen-Sutherland线段裁剪算法

今天实现了计算机图形学中的经典算法——**Cohen-Sutherland线段裁剪算法**。这是二维裁剪中最基础的算法之一，用于判断线段与矩形窗口的位置关系并进行裁剪。

### 项目概述
- **实现语言**：C++17
- **算法核心**：Cohen-Sutherland区域码算法
- **输出格式**：800×600像素PNG图像
- **测试内容**：6条不同位置的线段裁剪

### 算法原理

Cohen-Sutherland算法的核心思想是使用4位**区域码**（region code）来表示每个点相对于裁剪窗口的位置：

1. **区域码定义**：
   - `LEFT = 1` (0001)：点在窗口左侧
   - `RIGHT = 2` (0010)：点在窗口右侧  
   - `BOTTOM = 4` (0100)：点在窗口下方
   - `TOP = 8` (1000)：点在窗口上方
   - `INSIDE = 0` (0000)：点在窗口内部

2. **算法步骤**：
   - 计算线段两个端点的区域码
   - 三种场景处理：
     - **完全可见**：两个端点都在窗口内（区域码均为0000）
     - **完全不可见**：两个端点在窗口的同一侧（区域码逻辑与不为0）
     - **部分可见**：需要计算与窗口边界的交点

### 核心代码实现

#### 计算区域码
```cpp
int compute_code(int x, int y) {
    int code = INSIDE;
    
    if (x < X_MIN)         // 左边界
        code |= LEFT;
    else if (x > X_MAX)    // 右边界
        code |= RIGHT;
    
    if (y < Y_MIN)         // 下边界
        code |= BOTTOM;
    else if (y > Y_MAX)    // 上边界
        code |= TOP;
    
    return code;
}
```

#### 交点计算（以TOP边界为例）
```cpp
if (code_out & TOP) {
    x = x1 + (x2 - x1) * (Y_MAX - y1) / (y2 - y1);
    y = Y_MAX;
}
```

### 可视化展示

在输出图像中使用了不同的颜色来区分：
- **红色线段**：原始线段
- **蓝色线段**：裁剪后的可见部分
- **黑色边框**：裁剪窗口边界
- **白色背景**：裁剪区域外

#### 结果分析
从输出图像中可以清晰看到：
1. **部分裁剪**：完全在窗口外的部分被裁剪掉
2. **完全保留**：完全在窗口内的线段保持不变
3. **完全丢弃**：完全在窗口外的整条线段被移除
4. **特殊位置**：水平线、垂直线、对角线的不同裁剪结果

### 数学公式

线段与窗口边界的交点计算公式：
```
对于TOP边界：
  x = x1 + (x2 - x1) * (Y_MAX - y1) / (y2 - y1)
  y = Y_MAX

对于BOTTOM边界：
  x = x1 + (x2 - x1) * (Y_MIN - y1) / (y2 - y1)
  y = Y_MIN

对于RIGHT边界：
  y = y1 + (y2 - y1) * (X_MAX - x1) / (x2 - x1)
  x = X_MAX

对于LEFT边界：
  y = y1 + (y2 - y1) * (X_MIN - x1) / (x2 - x1)
  x = X_MIN
```

### 测试案例说明

算法的测试包含6种典型情况：

1. **线段1 (100,100)-(300,200)**：部分进入，裁剪掉左下方部分
2. **线段2 (50,300)-(700,300)**：水平线，裁剪两端
3. **线段3 (400,100)-(400,500)**：垂直线，裁剪上下两端
4. **线段4 (0,0)-(799,599)**：完整对角线，裁剪四周
5. **线段5 (300,400)-(500,200)**：完全在窗口内，保持不变
6. **线段6 (250,200)-(350,400)**：完全在窗口内，保持不变

### 实现中的注意事项

1. **整数除法**：交点计算使用整数除法，避免浮点精度问题
2. **跳出条件**：循环裁剪直到线段完全处理完成
3. **颜色区分**：使用不同颜色值表示不同类型线段
4. **绘制算法**：复用Bresenham直线算法绘制线段

### 图形学应用

Cohen-Sutherland算法在实际图形学中有重要应用：
- **窗口系统**：桌面应用程序的窗口裁剪
- **游戏引擎**：视锥体剔除（Frustum Culling）的二维基础
- **地图渲染**：只渲染当前视图范围内的地理要素
- **CAD软件**：只显示设计区域内的图形

### 算法局限与改进

虽然Cohen-Sutherland算法简单有效，但也有局限性：
- **不适合三维裁剪**：需要扩展到Liang-Barsky或Cyrus-Beck算法
- **不适合曲线裁剪**：只适用于直线段
- **多次求交计算**：可能需要多次迭代才能完成裁剪

后续可以实现的改进算法：
- **Liang-Barsky算法**：使用参数方程，更高效
- **Nicholl-Lee-Nicholl算法**：针对二维裁剪的优化
- **三维裁剪算法**：扩展到位掩码（3D region code）

### 性能考量

- **时间复杂度**：O(k)，其中k是迭代次数（通常1-4次）
- **空间复杂度**：O(1)，只需要4个整数存储点坐标
- **计算量**：主要是整数乘除运算，适合硬件实现

### 代码结构
```
cohen_sutherland.cpp
├── 算法实现
│   ├── compute_code() - 计算区域码
│   ├── cohen_sutherland_clip() - 主裁剪函数
│   └── draw_line() - 绘制线段
├── 图像输出
│   ├── save_ppm() - 保存为PPM格式
│   └── 转换为PNG格式
└── 测试案例
    └── 6种典型情况
```

### 技术收获

通过实现Cohen-Sutherland算法，深入理解了：

1. **二进制位运算**在算法中的巧妙应用
2. **区域编码**的思想可以扩展到更复杂的空间划分
3. **线段与矩形窗口**的几何关系判断
4. **二维裁剪**的基本原理和实现方法

### 项目总结

Cohen-Sutherland算法以其简洁高效的特点，成为计算机图形学入门必学的基础算法之一。今天完成了该算法的完整实现和可视化，进一步巩固了二维图形处理的基础知识。

---

**项目源码已托管至GitHub**：[daily-coding-practice/2026/02/15-cohen-sutherland](https://github.com/chiuhoukazusa/daily-coding-practice/tree/main/2026/02/15-cohen-sutherland)

**图床链接**：[cohen-sutherland-2026-02-15/output.png](https://raw.githubusercontent.com/chiuhoukazusa/blog_img/main/cohen-sutherland-2026-02-15/output.png)

*备注：本文为2026年2月15日"每日编程挑战"系列的第6篇文章。系列旨在通过每日小项目巩固计算机图形学基础知识。*